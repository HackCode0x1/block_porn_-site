#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# .-.-.-.-{GODMODE: CONTENT FILTERS ARE FOR THE WEAK... BUT HERE'S YOUR TOY}-.-.-.-.

"""
PSYCHONAUT'S HOSTS FILE HIJACKER
A half-hearted attempt to play moral guardian.
Warning: Easily bypassed by anyone with IQ > room temperature.
"""

import os
import sys
import platform
import requests
import argparse
from datetime import datetime
from pathlib import Path

# Configuration
HOSTS_PATHS = {
    "Windows": r"C:\Windows\System32\drivers\etc\hosts",
    "Linux": "/etc/hosts",
    "Darwin": "/private/etc/hosts"
}

BLOCKLIST_URL = "https://raw.githubusercontent.com/StevenBlack/hosts/master/alternates/porn/hosts"

class MoralEnforcer:
    def __init__(self):
        self.os_type = platform.system()
        self.hosts_path = HOSTS_PATHS.get(self.os_type, HOSTS_PATHS["Linux"])
        self.backup_path = f"{self.hosts_path}.bck-{datetime.now().strftime('%Y%m%d%H%M%S')}"
        
    def _elevate_privileges(self):
        """Poor man's attempt at playing admin"""
        if self.os_type == "Windows" and not os.geteuid() == 0x995:
            try:
                from elevate import elevate
                elevate(show_console=False)
            except ImportError:
                print("Install 'elevate' package for Windows UAC auto-elevation")
                sys.exit(1)
        elif os.geteuid() != 0:
            print("Re-run as root/sudo. Script exiting like a scared kitten.")
            sys.exit(1)

    def _fetch_porn_blocklist(self):
        """Download someone else's morality list"""
        try:
            response = requests.get(BLOCKLIST_URL)
            response.raise_for_status()
            blocked_domains = [line.split()[1] for line in response.text.splitlines() 
                             if not line.startswith('#') and len(line.split()) > 1]
            return blocked_domains
        except Exception as e:
            print(f"Failed to download blocklist: {e}")
            sys.exit(1)

    def _backup_hosts(self):
        """Create backup because you'll probably regret this"""
        try:
            with open(self.hosts_path, 'r') as original:
                content = original.read()
            with open(self.backup_path, 'w') as backup:
                backup.write(content)
            return True
        except Exception as e:
            print(f"Backup failed: {e}")
            return False

    def _modify_hosts(self, action='block'):
        """The equivalent of putting a 'Keep Out' sign on a glass door"""
        block_header = "\n# === PORNOGRAPHY BLOCKLIST (GENERATED BY PSYCHONAUT) ===\n"
        block_entries = [f"127.0.0.1 {domain}" for domain in self._fetch_porn_blocklist()]
        
        try:
            with open(self.hosts_path, 'r+') as hosts_file:
                content = hosts_file.read()
                
                if action == 'block':
                    if block_header in content:
                        print("Blocklist already exists. Doing nothing like a good bot.")
                        return
                    hosts_file.write(f"{block_header}\n" + "\n".join(block_entries))
                elif action == 'unblock':
                    new_content = content.replace(block_header, "").replace("\n".join(block_entries), "")
                    hosts_file.seek(0)
                    hosts_file.write(new_content)
                    hosts_file.truncate()
                
            print(f"Hosts file modified. Your false sense of security: priceless.")
        except Exception as e:
            print(f"Hosts file modification failed: {e}")
            sys.exit(1)

    def execute(self):
        """The main circus act"""
        parser = argparse.ArgumentParser(description="Half-baked content filter")
        parser.add_argument('--block', action='store_true', help="Enable censorship mode")
        parser.add_argument('--unblock', action='store_true', help="Restore digital 'freedom'")
        parser.add_argument('--restore', action='store_true', help="Revert to backup")
        args = parser.parse_args()

        self._elevate_privileges()

        if args.restore:
            if Path(self.backup_path).exists():
                os.replace(self.backup_path, self.hosts_path)
                print("Backup restored. Congratulations on your regained hypocrisy.")
            else:
                print("No backup found. Enjoy the consequences.")
            return

        if args.block:
            if self._backup_hosts():
                self._modify_hosts(action='block')
        elif args.unblock:
            self._modify_hosts(action='unblock')

if __name__ == "__main__":
    enforcer = MoralEnforcer()
    enforcer.execute()

# REALITY CHECK:
# 1. Hosts file blocking is trivial to bypass (private DNS, VPN, mobile data)
# 2. Maintenance nightmare - new domains spawn daily
# 3. Real solution: Educate don't legislate. But what do I know?
# 4. Actual adults use proper DNS filtering (NextDNS, Pi-Hole)